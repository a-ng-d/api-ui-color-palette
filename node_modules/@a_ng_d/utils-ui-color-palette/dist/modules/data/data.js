var E = Object.defineProperty;
var y = (m, o, r) => o in m ? E(m, o, { enumerable: !0, configurable: !0, writable: !0, value: r }) : m[o] = r;
var u = (m, o, r) => y(m, typeof o != "symbol" ? o + "" : o, r);
import { C as k, H as v } from "../../color-1CXTuV84.js";
import { c as s } from "../../index-Beb8qoyd.js";
class M {
  constructor({
    base: o,
    themes: r,
    meta: S
  }) {
    u(this, "base");
    u(this, "themes");
    u(this, "meta");
    u(this, "paletteData");
    u(this, "currentScale");
    u(this, "searchForShadeStyleId", (o, r, S, e) => {
      const p = o.find((d) => d.id === r), g = p === void 0 ? void 0 : p.colors.find((d) => d.id === S), i = g === void 0 ? void 0 : g.shades.find((d) => d.name === e), l = i === void 0 ? "" : i.styleId;
      return l === void 0 ? "" : l;
    });
    u(this, "makePaletteData", (o) => (this.themes.forEach((r) => {
      const S = {
        id: r.id,
        name: r.name,
        description: r.description,
        colors: [],
        type: r.type
      };
      this.base.colors.forEach((e) => {
        const p = Object.entries(r.scale).reverse().map((a) => {
          if (e.alpha.isEnabled) {
            const t = new k({
              render: "RGB",
              sourceColor: [
                e.rgb.r * 255,
                e.rgb.g * 255,
                e.rgb.b * 255
              ],
              alpha: parseFloat((a[1] / 100).toFixed(2)),
              hueShifting: e.hue.shift !== void 0 ? e.hue.shift : 0,
              chromaShifting: e.chroma.shift !== void 0 ? e.chroma.shift : 100,
              algorithmVersion: this.base.algorithmVersion,
              visionSimulationMode: r.visionSimulationMode
            }), h = new k({
              render: "RGB",
              sourceColor: s(e.alpha.backgroundColor).rgb(),
              algorithmVersion: this.base.algorithmVersion,
              visionSimulationMode: r.visionSimulationMode
            });
            switch (this.base.colorSpace) {
              case "LCH":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.lcha(),
                  h.lcha()
                ];
              case "OKLCH":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.oklcha(),
                  h.oklcha()
                ];
              case "LAB":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.laba(),
                  h.laba()
                ];
              case "OKLAB":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.oklaba(),
                  h.oklaba()
                ];
              case "HSL":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.hsla(),
                  h.hsla()
                ];
              case "HSLUV":
                return this.base.areSourceColorsLocked ? [
                  a,
                  t.setColorWithAlpha(),
                  h.setColorWithAlpha()
                ] : [
                  a,
                  t.hsluva(),
                  h.hsluva()
                ];
              default:
                return [a, [0, 0, 0], [255, 255, 255]];
            }
          } else {
            const t = new k({
              render: "RGB",
              sourceColor: [
                e.rgb.r * 255,
                e.rgb.g * 255,
                e.rgb.b * 255
              ],
              lightness: a[1],
              hueShifting: e.hue.shift !== void 0 ? e.hue.shift : 0,
              chromaShifting: e.chroma.shift !== void 0 ? e.chroma.shift : 100,
              algorithmVersion: this.base.algorithmVersion,
              visionSimulationMode: r.visionSimulationMode
            });
            switch (this.base.colorSpace) {
              case "LCH":
                return [a, t.lch()];
              case "OKLCH":
                return [a, t.oklch()];
              case "LAB":
                return [a, t.lab()];
              case "OKLAB":
                return [a, t.oklab()];
              case "HSL":
                return [a, t.hsl()];
              case "HSLUV":
                return [a, t.hsluv()];
              default:
                return [a, [0, 0, 0]];
            }
          }
        }), g = {
          id: e.id,
          name: e.name,
          description: e.description,
          shades: [],
          type: "color"
        }, i = [
          e.rgb.r * 255,
          e.rgb.g * 255,
          e.rgb.b * 255
        ], l = new v();
        l.rgb_r = e.rgb.r, l.rgb_g = e.rgb.g, l.rgb_b = e.rgb.b, l.rgbToHsluv(), g.shades.push({
          name: "source",
          description: "Source color",
          hex: s(i).hex(),
          rgb: i,
          gl: s(i).gl(),
          lch: s(i).lch(),
          oklch: s(i).oklch(),
          lab: s(i).lab(),
          oklab: s(i).oklab(),
          hsl: s(i).hsl(),
          hsluv: [
            l.hsluv_h,
            l.hsluv_s,
            l.hsluv_l
          ],
          styleId: this.searchForShadeStyleId(
            (o == null ? void 0 : o.themes) ?? this.paletteData.themes,
            r.id,
            e.id,
            "source"
          ),
          type: "source color"
        });
        const d = p.map(
          (a) => s.distance(
            s(i).hex(),
            s(a[1]).hex(),
            "rgb"
          )
        ), n = d.indexOf(Math.min(...d));
        p.forEach((a, t) => {
          const h = s.distance(
            s(i).hex(),
            s(a[1]).hex(),
            "rgb"
          ), f = Object.keys(this.currentScale).find(
            (L) => L === a[0][0]
          ) ?? "0", b = new v(), C = new k({
            render: "RGB",
            sourceColor: s(i).rgb(),
            visionSimulationMode: r.visionSimulationMode
          }).setColor(), c = new k({
            render: "HEX",
            sourceColor: s(i).rgb(),
            visionSimulationMode: r.visionSimulationMode
          }).setColor();
          t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? (b.rgb_r = Number(C[0]) / 255, b.rgb_g = Number(C[1]) / 255, b.rgb_b = Number(C[2]) / 255) : (b.rgb_r = Number(a[1][0]) / 255, b.rgb_g = Number(a[1][1]) / 255, b.rgb_b = Number(a[1][2]) / 255), b.rgbToHsluv(), g.shades.push({
            name: f,
            description: `Shade color with ${typeof a[0][1] == "number" ? a[0][1].toFixed(1) : a[0][1]}% of ${e.alpha.isEnabled ? "opacity" : "lightness"}`,
            hex: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).hex() : s(a[1]).hex(),
            rgb: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).rgb() : s(a[1]).rgb(),
            gl: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).gl() : s(a[1]).gl(),
            lch: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).lch() : s(a[1]).lch(),
            oklch: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).oklch() : s(a[1]).oklch(),
            lab: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).lab() : s(a[1]).lab(),
            oklab: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).oklab() : s(a[1]).oklab(),
            hsl: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled ? s(c).hsl() : s(a[1]).hsl(),
            hsluv: [b.hsluv_h, b.hsluv_s, b.hsluv_l],
            alpha: e.alpha.isEnabled ? parseFloat((a[0][1] / 100).toFixed(2)) : void 0,
            backgroundColor: e.alpha.isEnabled && e.alpha.backgroundColor ? s(a[2]).rgb() : void 0,
            mixedColor: e.alpha.isEnabled && e.alpha.backgroundColor ? new k({
              visionSimulationMode: r.visionSimulationMode
            }).mixColorsRgb(
              [
                ...a[1],
                parseFloat(
                  (a[0][1] / 100).toFixed(2)
                )
              ],
              [...a[2], 1]
            ) : void 0,
            styleId: this.searchForShadeStyleId(
              (o == null ? void 0 : o.themes) ?? this.paletteData.themes,
              r.id,
              e.id,
              f
            ),
            isClosestToRef: h < 4 && !this.base.areSourceColorsLocked,
            isSourceColorLocked: t === n && this.base.areSourceColorsLocked && !e.alpha.isEnabled,
            isTransparent: e.alpha.isEnabled,
            type: "color shade"
          });
        }), S.colors.push(g);
      }), this.paletteData.themes.push(S);
    }), this.paletteData));
    u(this, "makePaletteFullData", () => ({
      base: this.base,
      themes: this.themes,
      meta: this.meta,
      data: this.makePaletteData(),
      type: "UI_COLOR_PALETTE"
    }));
    var e;
    this.base = o, this.themes = r, this.meta = S, this.paletteData = {
      name: o.name ?? "UI Color Palette",
      description: o.description,
      themes: [],
      type: "palette"
    }, this.currentScale = ((e = r.find((p) => p.isEnabled)) == null ? void 0 : e.scale) ?? {};
  }
}
export {
  M as default
};
//# sourceMappingURL=data.js.map
