var f = Object.defineProperty;
var T = (b, t, h) => t in b ? f(b, t, { enumerable: !0, configurable: !0, writable: !0, value: h }) : b[t] = h;
var l = (b, t, h) => T(b, typeof t != "symbol" ? t + "" : t, h);
import { c as n } from "./index-Beb8qoyd.js";
class s {
  constructor() {
    this.hex = "#000000", this.rgb_r = 0, this.rgb_g = 0, this.rgb_b = 0, this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0, this.luv_l = 0, this.luv_u = 0, this.luv_v = 0, this.lch_l = 0, this.lch_c = 0, this.lch_h = 0, this.hsluv_h = 0, this.hsluv_s = 0, this.hsluv_l = 0, this.hpluv_h = 0, this.hpluv_p = 0, this.hpluv_l = 0, this.r0s = 0, this.r0i = 0, this.r1s = 0, this.r1i = 0, this.g0s = 0, this.g0i = 0, this.g1s = 0, this.g1i = 0, this.b0s = 0, this.b0i = 0, this.b1s = 0, this.b1i = 0;
  }
  static fromLinear(t) {
    return t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055;
  }
  static toLinear(t) {
    return t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92;
  }
  static yToL(t) {
    return t <= s.epsilon ? t / s.refY * s.kappa : 116 * Math.pow(t / s.refY, 1 / 3) - 16;
  }
  static lToY(t) {
    return t <= 8 ? s.refY * t / s.kappa : s.refY * Math.pow((t + 16) / 116, 3);
  }
  static rgbChannelToHex(t) {
    const h = Math.round(t * 255), r = h % 16, o = (h - r) / 16 | 0;
    return s.hexChars.charAt(o) + s.hexChars.charAt(r);
  }
  static hexToRgbChannel(t, h) {
    const r = s.hexChars.indexOf(t.charAt(h)), o = s.hexChars.indexOf(t.charAt(h + 1));
    return (r * 16 + o) / 255;
  }
  static distanceFromOriginAngle(t, h, r) {
    const o = h / (Math.sin(r) - t * Math.cos(r));
    return o < 0 ? 1 / 0 : o;
  }
  static distanceFromOrigin(t, h) {
    return Math.abs(h) / Math.sqrt(Math.pow(t, 2) + 1);
  }
  static min6(t, h, r, o, i, e) {
    return Math.min(t, Math.min(h, Math.min(r, Math.min(o, Math.min(i, e)))));
  }
  rgbToHex() {
    this.hex = "#", this.hex += s.rgbChannelToHex(this.rgb_r), this.hex += s.rgbChannelToHex(this.rgb_g), this.hex += s.rgbChannelToHex(this.rgb_b);
  }
  hexToRgb() {
    this.hex = this.hex.toLowerCase(), this.rgb_r = s.hexToRgbChannel(this.hex, 1), this.rgb_g = s.hexToRgbChannel(this.hex, 3), this.rgb_b = s.hexToRgbChannel(this.hex, 5);
  }
  xyzToRgb() {
    this.rgb_r = s.fromLinear(s.m_r0 * this.xyz_x + s.m_r1 * this.xyz_y + s.m_r2 * this.xyz_z), this.rgb_g = s.fromLinear(s.m_g0 * this.xyz_x + s.m_g1 * this.xyz_y + s.m_g2 * this.xyz_z), this.rgb_b = s.fromLinear(s.m_b0 * this.xyz_x + s.m_b1 * this.xyz_y + s.m_b2 * this.xyz_z);
  }
  rgbToXyz() {
    const t = s.toLinear(this.rgb_r), h = s.toLinear(this.rgb_g), r = s.toLinear(this.rgb_b);
    this.xyz_x = 0.41239079926595 * t + 0.35758433938387 * h + 0.18048078840183 * r, this.xyz_y = 0.21263900587151 * t + 0.71516867876775 * h + 0.072192315360733 * r, this.xyz_z = 0.019330818715591 * t + 0.11919477979462 * h + 0.95053215224966 * r;
  }
  xyzToLuv() {
    const t = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z;
    let h = 4 * this.xyz_x, r = 9 * this.xyz_y;
    t !== 0 ? (h /= t, r /= t) : (h = NaN, r = NaN), this.luv_l = s.yToL(this.xyz_y), this.luv_l === 0 ? (this.luv_u = 0, this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (h - s.refU), this.luv_v = 13 * this.luv_l * (r - s.refV));
  }
  luvToXyz() {
    if (this.luv_l === 0) {
      this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0;
      return;
    }
    const t = this.luv_u / (13 * this.luv_l) + s.refU, h = this.luv_v / (13 * this.luv_l) + s.refV;
    this.xyz_y = s.lToY(this.luv_l), this.xyz_x = 0 - 9 * this.xyz_y * t / ((t - 4) * h - t * h), this.xyz_z = (9 * this.xyz_y - 15 * h * this.xyz_y - h * this.xyz_x) / (3 * h);
  }
  luvToLch() {
    if (this.lch_l = this.luv_l, this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v), this.lch_c < 1e-8)
      this.lch_h = 0;
    else {
      const t = Math.atan2(this.luv_v, this.luv_u);
      this.lch_h = t * 180 / Math.PI, this.lch_h < 0 && (this.lch_h = 360 + this.lch_h);
    }
  }
  lchToLuv() {
    const t = this.lch_h / 180 * Math.PI;
    this.luv_l = this.lch_l, this.luv_u = Math.cos(t) * this.lch_c, this.luv_v = Math.sin(t) * this.lch_c;
  }
  calculateBoundingLines(t) {
    const h = Math.pow(t + 16, 3) / 1560896, r = h > s.epsilon ? h : t / s.kappa, o = r * (284517 * s.m_r0 - 94839 * s.m_r2), i = r * (838422 * s.m_r2 + 769860 * s.m_r1 + 731718 * s.m_r0), e = r * (632260 * s.m_r2 - 126452 * s.m_r1), a = r * (284517 * s.m_g0 - 94839 * s.m_g2), g = r * (838422 * s.m_g2 + 769860 * s.m_g1 + 731718 * s.m_g0), m = r * (632260 * s.m_g2 - 126452 * s.m_g1), _ = r * (284517 * s.m_b0 - 94839 * s.m_b2), M = r * (838422 * s.m_b2 + 769860 * s.m_b1 + 731718 * s.m_b0), C = r * (632260 * s.m_b2 - 126452 * s.m_b1);
    this.r0s = o / e, this.r0i = i * t / e, this.r1s = o / (e + 126452), this.r1i = (i - 769860) * t / (e + 126452), this.g0s = a / m, this.g0i = g * t / m, this.g1s = a / (m + 126452), this.g1i = (g - 769860) * t / (m + 126452), this.b0s = _ / C, this.b0i = M * t / C, this.b1s = _ / (C + 126452), this.b1i = (M - 769860) * t / (C + 126452);
  }
  calcMaxChromaHpluv() {
    const t = s.distanceFromOrigin(this.r0s, this.r0i), h = s.distanceFromOrigin(this.r1s, this.r1i), r = s.distanceFromOrigin(this.g0s, this.g0i), o = s.distanceFromOrigin(this.g1s, this.g1i), i = s.distanceFromOrigin(this.b0s, this.b0i), e = s.distanceFromOrigin(this.b1s, this.b1i);
    return s.min6(t, h, r, o, i, e);
  }
  calcMaxChromaHsluv(t) {
    const h = t / 360 * Math.PI * 2, r = s.distanceFromOriginAngle(this.r0s, this.r0i, h), o = s.distanceFromOriginAngle(this.r1s, this.r1i, h), i = s.distanceFromOriginAngle(this.g0s, this.g0i, h), e = s.distanceFromOriginAngle(this.g1s, this.g1i, h), a = s.distanceFromOriginAngle(this.b0s, this.b0i, h), g = s.distanceFromOriginAngle(this.b1s, this.b1i, h);
    return s.min6(r, o, i, e, a, g);
  }
  hsluvToLch() {
    if (this.hsluv_l > 99.9999999)
      this.lch_l = 100, this.lch_c = 0;
    else if (this.hsluv_l < 1e-8)
      this.lch_l = 0, this.lch_c = 0;
    else {
      this.lch_l = this.hsluv_l, this.calculateBoundingLines(this.hsluv_l);
      const t = this.calcMaxChromaHsluv(this.hsluv_h);
      this.lch_c = t / 100 * this.hsluv_s;
    }
    this.lch_h = this.hsluv_h;
  }
  lchToHsluv() {
    if (this.lch_l > 99.9999999)
      this.hsluv_s = 0, this.hsluv_l = 100;
    else if (this.lch_l < 1e-8)
      this.hsluv_s = 0, this.hsluv_l = 0;
    else {
      this.calculateBoundingLines(this.lch_l);
      const t = this.calcMaxChromaHsluv(this.lch_h);
      this.hsluv_s = this.lch_c / t * 100, this.hsluv_l = this.lch_l;
    }
    this.hsluv_h = this.lch_h;
  }
  hpluvToLch() {
    if (this.hpluv_l > 99.9999999)
      this.lch_l = 100, this.lch_c = 0;
    else if (this.hpluv_l < 1e-8)
      this.lch_l = 0, this.lch_c = 0;
    else {
      this.lch_l = this.hpluv_l, this.calculateBoundingLines(this.hpluv_l);
      const t = this.calcMaxChromaHpluv();
      this.lch_c = t / 100 * this.hpluv_p;
    }
    this.lch_h = this.hpluv_h;
  }
  lchToHpluv() {
    if (this.lch_l > 99.9999999)
      this.hpluv_p = 0, this.hpluv_l = 100;
    else if (this.lch_l < 1e-8)
      this.hpluv_p = 0, this.hpluv_l = 0;
    else {
      this.calculateBoundingLines(this.lch_l);
      const t = this.calcMaxChromaHpluv();
      this.hpluv_p = this.lch_c / t * 100, this.hpluv_l = this.lch_l;
    }
    this.hpluv_h = this.lch_h;
  }
  hsluvToRgb() {
    this.hsluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb();
  }
  hpluvToRgb() {
    this.hpluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb();
  }
  hsluvToHex() {
    this.hsluvToRgb(), this.rgbToHex();
  }
  hpluvToHex() {
    this.hpluvToRgb(), this.rgbToHex();
  }
  rgbToHsluv() {
    this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHsluv();
  }
  rgbToHpluv() {
    this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHpluv();
  }
  hexToHsluv() {
    this.hexToRgb(), this.rgbToHsluv();
  }
  hexToHpluv() {
    this.hexToRgb(), this.rgbToHpluv();
  }
}
s.hexChars = "0123456789abcdef";
s.refY = 1;
s.refU = 0.19783000664283;
s.refV = 0.46831999493879;
s.kappa = 903.2962962;
s.epsilon = 0.0088564516;
s.m_r0 = 3.240969941904521;
s.m_r1 = -1.537383177570093;
s.m_r2 = -0.498610760293;
s.m_g0 = -0.96924363628087;
s.m_g1 = 1.87596750150772;
s.m_g2 = 0.041555057407175;
s.m_b0 = 0.055630079696993;
s.m_b1 = -0.20397695888897;
s.m_b2 = 1.056971514242878;
const u = {
  PROTANOPIA: [
    [0.567, 0.433, 0],
    [0.558, 0.442, 0],
    [0, 0.242, 0.758]
  ],
  PROTANOMALY: [
    [0.817, 0.183, 0],
    [0.333, 0.667, 0],
    [0, 0.125, 0.875]
  ],
  DEUTERANOPIA: [
    [0.625, 0.375, 0],
    [0.7, 0.3, 0],
    [0, 0.3, 0.7]
  ],
  DEUTERANOMALY: [
    [0.8, 0.2, 0],
    [0.258, 0.742, 0],
    [0, 0.142, 0.858]
  ],
  TRITANOPIA: [
    [0.95, 0.05, 0],
    [0, 0.433, 0.567],
    [0, 0.475, 0.525]
  ],
  TRITANOMALY: [
    [0.967, 0.033, 0],
    [0, 0.733, 0.267],
    [0, 0.183, 0.817]
  ],
  ACHROMATOPSIA: [
    [0.299, 0.587, 0.114],
    [0.299, 0.587, 0.114],
    [0.299, 0.587, 0.114]
  ],
  ACHROMATOMALY: [
    [0.618, 0.32, 0.062],
    [0.163, 0.775, 0.062],
    [0.163, 0.32, 0.516]
  ]
}, c = (b, t) => {
  const [h, r, o] = b, [i, e, a] = t;
  return [
    Math.round(h * i[0] + r * i[1] + o * i[2]),
    Math.round(h * e[0] + r * e[1] + o * e[2]),
    Math.round(h * a[0] + r * a[1] + o * a[2])
  ];
};
class p {
  constructor({
    render: t = "HEX",
    sourceColor: h = [0, 0, 0],
    lightness: r = parseFloat((n(h).luminance() * 100).toFixed(1)),
    alpha: o = 1,
    hueShifting: i = 0,
    chromaShifting: e = 100,
    algorithmVersion: a = "v3",
    visionSimulationMode: g = "NONE"
  }) {
    l(this, "render");
    l(this, "sourceColor");
    l(this, "lightness");
    l(this, "alpha");
    l(this, "hueShifting");
    l(this, "chromaShifting");
    l(this, "algorithmVersion");
    l(this, "visionSimulationMode");
    l(this, "adjustHue", (t) => t + this.hueShifting < 0 ? t + this.hueShifting + 360 : t + this.hueShifting > 360 ? t + this.hueShifting - 360 : t + this.hueShifting);
    l(this, "adjustChroma", (t) => {
      if (this.algorithmVersion === "v1") return t;
      if (this.algorithmVersion === "v2")
        return Math.sin(this.lightness / 100 * Math.PI) * t;
      if (this.algorithmVersion === "v3") {
        const h = this.lightness / 100, r = Math.sin(h * Math.PI), o = Math.tanh(h * Math.PI), i = r * 0.5 + o * 0.5;
        return Math.pow(i, 0.5) * t;
      }
      return t;
    });
    l(this, "setColor", () => this.render === "HEX" ? this.simulateColorBlindHex(this.sourceColor) : this.simulateColorBlindRgb(this.sourceColor));
    l(this, "setColorWithAlpha", () => this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(this.sourceColor), this.alpha).hex() : [...this.simulateColorBlindRgb(this.sourceColor), this.alpha]);
    l(this, "lch", () => {
      const t = n(this.sourceColor).lch(), h = n.lch(
        this.lightness,
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        this.adjustHue(t[2])
      ).rgb();
      return this.render === "HEX" ? this.simulateColorBlindHex(h) : this.simulateColorBlindRgb(h);
    });
    l(this, "lcha", () => {
      const t = n(this.sourceColor).lch(), h = n.lch(
        t[0],
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        this.adjustHue(t[2])
      ).rgb();
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(h), this.alpha).hex() : [...this.simulateColorBlindRgb(h), this.alpha];
    });
    l(this, "oklch", () => {
      const t = n(this.sourceColor).oklch(), h = n.oklch(
        this.lightness / 100,
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        this.adjustHue(t[2])
      ).rgb();
      return this.render === "HEX" ? this.simulateColorBlindHex(h) : this.simulateColorBlindRgb(h);
    });
    l(this, "oklcha", () => {
      const t = n(this.sourceColor).oklch(), h = n.oklch(
        t[0],
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        this.adjustHue(t[2])
      ).rgb();
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(h), this.alpha).hex() : [...this.simulateColorBlindRgb(h), this.alpha];
    });
    l(this, "lab", () => {
      const t = n(this.sourceColor).get("lab.a"), h = n(this.sourceColor).get("lab.b"), r = Math.sqrt(t ** 2 + h ** 2) * (this.chromaShifting / 100);
      let o = Math.atan(h / t) + this.hueShifting * (Math.PI / 180);
      (o > Math.PI || o < -Math.PI) && (o = Math.PI);
      let i = r * Math.cos(o), e = r * Math.sin(o);
      Math.sign(t) === -1 && Math.sign(h) === 1 && (i *= -1, e *= -1), Math.sign(t) === -1 && Math.sign(h) === -1 && (i *= -1, e *= -1);
      const a = n.lab(
        this.lightness,
        this.adjustChroma(i),
        this.adjustChroma(e)
      ).rgb();
      return this.render === "HEX" ? this.simulateColorBlindHex(a) : this.simulateColorBlindRgb(a);
    });
    l(this, "laba", () => {
      const t = n(this.sourceColor).get("lab.a"), h = n(this.sourceColor).get("lab.b"), r = n(this.sourceColor).get("lab.l"), o = Math.sqrt(t ** 2 + h ** 2) * (this.chromaShifting / 100);
      let i = Math.atan(h / t) + this.hueShifting * (Math.PI / 180);
      (i > Math.PI || i < -Math.PI) && (i = Math.PI);
      let e = o * Math.cos(i), a = o * Math.sin(i);
      Math.sign(t) === -1 && Math.sign(h) === 1 && (e *= -1, a *= -1), Math.sign(t) === -1 && Math.sign(h) === -1 && (e *= -1, a *= -1);
      const g = n.lab(r, this.adjustChroma(e), this.adjustChroma(a)).rgb();
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(g), this.alpha).hex() : [...this.simulateColorBlindRgb(g), this.alpha];
    });
    l(this, "oklab", () => {
      const t = n(this.sourceColor).get("oklab.a"), h = n(this.sourceColor).get("oklab.b"), r = Math.sqrt(t ** 2 + h ** 2) * (this.chromaShifting / 100);
      let o = Math.atan(h / t) + this.hueShifting * (Math.PI / 180);
      (o > Math.PI || o < -Math.PI) && (o = Math.PI);
      let i = r * Math.cos(o), e = r * Math.sin(o);
      Math.sign(t) === -1 && Math.sign(h) === 1 && (i *= -1, e *= -1), Math.sign(t) === -1 && Math.sign(h) === -1 && (i *= -1, e *= -1), Number.isNaN(i) && (i = 0), Number.isNaN(e) && (e = 0);
      const a = n.oklab(
        this.lightness / 100,
        this.adjustChroma(i),
        this.adjustChroma(e)
      ).rgb();
      return this.render === "HEX" ? this.simulateColorBlindHex(a) : this.simulateColorBlindRgb(a);
    });
    l(this, "oklaba", () => {
      const t = n(this.sourceColor).get("oklab.a"), h = n(this.sourceColor).get("oklab.b"), r = n(this.sourceColor).get("oklab.l"), o = Math.sqrt(t ** 2 + h ** 2) * (this.chromaShifting / 100);
      let i = Math.atan(h / t) + this.hueShifting * (Math.PI / 180);
      (i > Math.PI || i < -Math.PI) && (i = Math.PI);
      let e = o * Math.cos(i), a = o * Math.sin(i);
      Math.sign(t) === -1 && Math.sign(h) === 1 && (e *= -1, a *= -1), Math.sign(t) === -1 && Math.sign(h) === -1 && (e *= -1, a *= -1), Number.isNaN(e) && (e = 0), Number.isNaN(a) && (a = 0);
      const g = n.oklab(r, this.adjustChroma(e), this.adjustChroma(a)).rgb();
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(g), this.alpha).hex() : [...this.simulateColorBlindRgb(g), this.alpha];
    });
    l(this, "hsl", () => {
      const t = n(this.sourceColor).hsl(), h = n.hsl(
        this.adjustHue(t[0]),
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        this.lightness / 100
      ).rgb();
      return this.render === "HEX" ? this.simulateColorBlindHex(h) : this.simulateColorBlindRgb(h);
    });
    l(this, "hsla", () => {
      const t = n(this.sourceColor).hsl(), h = n.hsl(
        this.adjustHue(t[0]),
        this.adjustChroma(t[1] * (this.chromaShifting / 100)),
        t[2]
      ).rgb();
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(h), this.alpha).hex() : [...this.simulateColorBlindRgb(h), this.alpha];
    });
    l(this, "hsluv", () => {
      const t = new s();
      t.rgb_r = this.sourceColor[0] / 255, t.rgb_g = this.sourceColor[1] / 255, t.rgb_b = this.sourceColor[2] / 255, t.rgbToHsluv(), t.hsluv_l = this.lightness, t.hsluv_s = this.adjustChroma(
        t.hsluv_s * (this.chromaShifting / 100)
      ), t.hsluv_h = this.adjustHue(t.hsluv_h), Number.isNaN(t.hsluv_s) && (t.hsluv_s = 0), Number.isNaN(t.hsluv_h) && (t.hsluv_h = 0), t.hsluvToRgb();
      const h = [
        t.rgb_r * 255,
        t.rgb_g * 255,
        t.rgb_b * 255
      ];
      return this.render === "HEX" ? this.simulateColorBlindHex(h) : this.simulateColorBlindRgb(h);
    });
    l(this, "hsluva", () => {
      const t = new s();
      t.rgb_r = this.sourceColor[0] / 255, t.rgb_g = this.sourceColor[1] / 255, t.rgb_b = this.sourceColor[2] / 255, t.rgbToHsluv(), t.hsluv_s = this.adjustChroma(
        t.hsluv_s * (this.chromaShifting / 100)
      ), t.hsluv_h = this.adjustHue(t.hsluv_h), Number.isNaN(t.hsluv_s) && (t.hsluv_s = 0), Number.isNaN(t.hsluv_h) && (t.hsluv_h = 0), t.hsluvToRgb();
      const h = [
        t.rgb_r * 255,
        t.rgb_g * 255,
        t.rgb_b * 255
      ];
      return this.render === "HEX" ? n.rgb(...this.simulateColorBlindRgb(h), this.alpha).hex() : [...this.simulateColorBlindRgb(h), this.alpha];
    });
    l(this, "getHsluv", () => {
      const t = new s();
      return t.rgb_r = this.sourceColor[0] / 255, t.rgb_g = this.sourceColor[1] / 255, t.rgb_b = this.sourceColor[2] / 255, t.rgbToHsluv(), [t.hsluv_h, t.hsluv_s, t.hsluv_l];
    });
    l(this, "simulateColorBlindHex", (t) => {
      var o;
      const h = {
        NONE: () => n(t).hex(),
        PROTANOMALY: () => {
          const i = c(
            t,
            u.PROTANOMALY
          );
          return n(i).hex();
        },
        PROTANOPIA: () => {
          const i = c(
            t,
            u.PROTANOPIA
          );
          return n(i).hex();
        },
        DEUTERANOMALY: () => {
          const i = c(
            t,
            u.DEUTERANOMALY
          );
          return n(i).hex();
        },
        DEUTERANOPIA: () => {
          const i = c(
            t,
            u.DEUTERANOPIA
          );
          return n(i).hex();
        },
        TRITANOMALY: () => {
          const i = c(
            t,
            u.TRITANOMALY
          );
          return n(i).hex();
        },
        TRITANOPIA: () => {
          const i = c(
            t,
            u.TRITANOPIA
          );
          return n(i).hex();
        },
        ACHROMATOMALY: () => {
          const i = c(
            t,
            u.ACHROMATOMALY
          );
          return n(i).hex();
        },
        ACHROMATOPSIA: () => {
          const i = c(
            t,
            u.ACHROMATOPSIA
          );
          return n(i).hex();
        }
      }, r = (o = h[this.visionSimulationMode]) == null ? void 0 : o.call(h);
      return r !== void 0 ? r : "#000000";
    });
    l(this, "simulateColorBlindRgb", (t) => {
      var o;
      const h = {
        NONE: () => n(t).rgb(),
        PROTANOMALY: () => c(t, u.PROTANOMALY),
        PROTANOPIA: () => c(t, u.PROTANOPIA),
        DEUTERANOMALY: () => c(t, u.DEUTERANOMALY),
        DEUTERANOPIA: () => c(t, u.DEUTERANOPIA),
        TRITANOMALY: () => c(t, u.TRITANOMALY),
        TRITANOPIA: () => c(t, u.TRITANOPIA),
        ACHROMATOMALY: () => c(t, u.ACHROMATOMALY),
        ACHROMATOPSIA: () => c(t, u.ACHROMATOPSIA)
      }, r = (o = h[this.visionSimulationMode]) == null ? void 0 : o.call(h);
      return r !== void 0 ? r : [0, 0, 0];
    });
    l(this, "mixColorsRgb", (t, h) => {
      const [r, o, i, e] = t, [a, g, m, _] = h;
      if (e === 1) return [r, o, i];
      if (e === 0) return [a, g, m];
      const M = e + _ * (1 - e), C = Math.min(
        255,
        Math.max(0, Math.round((r * e + a * _ * (1 - e)) / M))
      ), d = Math.min(
        255,
        Math.max(0, Math.round((o * e + g * _ * (1 - e)) / M))
      ), x = Math.min(
        255,
        Math.max(0, Math.round((i * e + m * _ * (1 - e)) / M))
      );
      return this.simulateColorBlindRgb([C, d, x]);
    });
    l(this, "mixColorsHex", (t, h) => {
      const r = /^#([0-9A-Fa-f]{3}){1,2}([0-9A-Fa-f]{2})?$/;
      if (!r.test(t)) return t;
      if (!r.test(h)) return h;
      const o = n(t).rgba(), i = n(h).rgba(), e = this.mixColorsRgb(o, i);
      return n(e).hex();
    });
    this.render = t, this.sourceColor = h, this.lightness = r, this.alpha = o, this.hueShifting = i, this.chromaShifting = e, this.algorithmVersion = a, this.visionSimulationMode = g;
  }
}
export {
  p as C,
  s as H
};
//# sourceMappingURL=color-1CXTuV84.js.map
